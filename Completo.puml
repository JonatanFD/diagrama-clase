@startuml
package "Design Domain" {
  package "Design Domain Layer" {
    enum ExportFormat {
      IMAGE,
      PDF
    }

    enum TextAlignment {
      LEFT,
      CENTER,
      RIGHT
    }

    class Design <<Entity>> {
      - UUID id
      - String name
      - String description
      - UUID ownerId
      - Date creationDate
      - List<Layer> layers
      - boolean isPublic
      + addLayer(Layer layer): void
      + removeLayer(Layer layer): void
      + getPreview(): Image
      + getLayers(): List<Layer>
      + duplicateDesign(): Design
      + exportDesign(format: ExportFormat): File
    }

    abstract class Layer <<Entity>> {
      - String name
      - float positionX
      - float positionY
      - float rotation
      - float scale
      - int zIndex
      - boolean locked
      + move(float x, float y): void
      + scaleTo(float value): void
      + rotate(float degrees): void
      + lock(): void
      + unlock(): void
      + isLocked(): boolean
    }

    class TextLayer <<Entity>> extends Layer {
      - String text
      - String font
      - String color
      - float fontSize
      - TextAlignment alignment
      - boolean bold
      - boolean italic
      - boolean underline
      + updateText(String newText): void
      + changeFont(String newFont): void
      + changeColor(String newColor): void
      + changeFontSize(float newSize): void
      + changeAlignment(TextAlignment alignment): void
    }

    class ImageLayer <<Entity>> extends Layer {
      - String imageUrl
      - float opacity
      - float width
      - float height
      - boolean maintainAspectRatio
      + updateImage(String newUrl): void
      + changeOpacity(float newOpacity): void
      + getImageUrl(): String
      + resize(float newWidth, float newHeight): void
    }

    class ShapeLayer <<Entity>> extends Layer {
      - String shapeType
      - String fillColor
      - String borderColor
      - float borderWidth
      - String shapeId
      + updateShape(String newShapeType): void
      + updateColors(String newFillColor, String newBorderColor): void
    }

    class Template <<Entity>> {
      - UUID id
      - String name
      - String category
      - boolean isPremium
      - Design baseDesign
      + getDesign(): Design
    }

    Template "1" --> "1" Design : baseDesign
    Design "1" --> "*" Layer : contains
  }

  package "Design Application Layer" {
    class TemplateService {
      + createTemplate(String name, Design baseDesign): Template
      + getTemplateById(UUID id): Template
      + listTemplates(): List<Template>
    }

    class DesignService {
      + addLayerToDesign(UUID designId, Layer layer): void
      + removeLayerFromDesign(UUID designId, Layer layer): void
      + updateLayer(UUID designId, Layer updatedLayer): void
      + getPreview(UUID designId): Image
      + duplicateDesign(UUID designId): Design
      + exportDesign(UUID designId, ExportFormat format): File
    }

    TemplateService --> Template
    DesignService --> Design
  }

  package "Design Infrastructure Layer" {
    class CloudinaryAdapter {
      + uploadImage(byte[] imageData): String
      + deleteImage(String imageUrl): void
      + transformImage(String url, Map<String, String> options): String
      + getImageMetadata(String url): ImageMetadata
    }

    ImageLayer --> CloudinaryAdapter : uses >
  }

  package "Design Interface Layer" {
    class TemplateController {
      + getTemplate(UUID id): Template
      + createTemplate(String name, Design baseDesign): Template
      + listTemplates(): List<Template>
    }

    class DesignController {
      + postLayer(UUID designId, Layer layer): void
      + deleteLayer(UUID designId, Layer layer): void
      + updateLayer(UUID designId, Layer updatedLayer): void
      + getPreview(UUID designId): Image
      + duplicateDesign(UUID designId): Design
      + exportDesign(UUID designId, ExportFormat format): File
    }

    TemplateController --> TemplateService
    DesignController --> DesignService
  }
}

' =============================
' FULFILLMENT DOMAIN
' =============================
package "Fulfillment Domain" {
  package "Fulfillment Domain Layer" {
    class Fulfillment <<Entity>> {
      - UUID id
      - Order order
      - FulfillmentStatus status
      - FulfillmentDate fulfillmentDate
      - boolean isCanceled
      - Date shippedAt
      - Date packedAt
      + start(): void
      + markPacked(): void
      + markShipped(): void
      + getStatus(): FulfillmentStatus
      + cancel(): void
      + isDelayed(): boolean
      + estimateDeliveryDate(): Date
    }

    enum FulfillmentStatus {
      PENDING
      IN_PRODUCTION
      PACKED
      SHIPPED
      DELIVERED
      CANCELED
    }

    class FulfillmentDate <<ValueObject>> {
      - Date startedAt
      - Date completedAt
      + getStartedAt(): Date
      + getCompletedAt(): Date
      + calculateDuration(): long
    }

    interface FulfillmentRepository {
      + save(Fulfillment fulfillment): void
      + findByOrderId(UUID orderId): Fulfillment
      + updateStatus(UUID orderId, FulfillmentStatus status): void
    }

    Fulfillment --> FulfillmentStatus
    Fulfillment --> FulfillmentDate
  }

  package "Fulfillment Application Layer" {
    class FulfillmentService {
      - FulfillmentRepository fulfillmentRepository
      - ShippingService shippingService
      + initiateFulfillment(UUID orderId): void
      + packOrder(UUID orderId): void
      + shipOrder(UUID orderId): void
      + cancelFulfillment(UUID orderId): void
      + getEstimatedDeliveryDate(UUID orderId): Date
      + isOrderDelayed(UUID orderId): boolean
    }

    FulfillmentService --> Fulfillment
    FulfillmentService --> FulfillmentRepository
  }

  package "Fulfillment Infrastructure Layer" {
    class FulfillmentRepositoryImpl {
      - Map<UUID, Fulfillment> database
      + save(Fulfillment fulfillment): void
      + findByOrderId(UUID orderId): Fulfillment
      + updateStatus(UUID orderId, FulfillmentStatus status): void
    }

    FulfillmentRepositoryImpl ..|> FulfillmentRepository
  }

  package "Fulfillment Interface Layer"  {
    class FulfillmentController {
      - FulfillmentService fulfillmentService
      + startFulfillment(UUID orderId): String
      + packOrder(UUID orderId): String
      + shipOrder(UUID orderId): String
      + cancelFulfillment(UUID orderId): String
      + getEstimatedDeliveryDate(UUID orderId): Date
      + isOrderDelayed(UUID orderId): boolean
    }

    FulfillmentController --> FulfillmentService
  }
}

' =============================
' ORDER DOMAIN
' =============================
package "Order Domain" {
  package "Order Domain Layer"  {
    class Order <<Entity>> {
      - UUID id
      - Date orderDate
      - OrderStatus status
      - User customer
      - List<OrderItem> items
      + calculateTotal(): Money
      + markAsReady(): void
      + addItem(OrderItem item): void
    }

    class OrderItem <<Entity>> {
      - UUID id
      - ProductName productName
      - Quantity quantity
      - Money unitPrice
      + getSubtotal(): Money
    }

    enum OrderStatus {
      PENDING
      PAID
      CANCELLED
      READY_FOR_PRODUCTION
    }

    interface OrderRepository {
      + save(Order order): void
      + findById(UUID id): Order
      + update(Order order): void
    }

    ' Value Objects
    class Money <<ValueObject>> {
      - double amount
      - String currency
      + getAmount(): double
      + getCurrency(): String
    }

    class Quantity <<ValueObject>> {
      - int value
      + getValue(): int
    }

    class ProductName <<ValueObject>> {
      - String value
      + getValue(): String
    }

    Order --> OrderItem : contains >
    Order --> OrderStatus
    OrderItem --> Money
    OrderItem --> Quantity
    OrderItem --> ProductName

    ' Connect Fulfillment to Order
    Fulfillment "1" --> "1" Order
  }

  package "Order Application Layer"  {
    interface PaymentGateway {
      + processPayment(UUID orderId, Money amount, String paymentMethod): boolean
      + refundPayment(UUID orderId): boolean
      + validateCard(String cardNumber, String cvv, String expiryDate): boolean
      + getPaymentStatus(UUID orderId): String
    }

    class OrderService {
      - OrderRepository orderRepository
      - PaymentGateway paymentGateway
      + createOrder(User user, List<OrderItem> items): Order
      + payOrder(UUID orderId): void
      + cancelOrder(UUID orderId): void
      + markOrderReady(UUID orderId): void
    }

    OrderService --> Order
    OrderService --> OrderRepository
    OrderService --> PaymentGateway
  }

  package "Order Infrastructure Layer"  {
    class OrderRepositoryImpl {
      - Map<UUID, Order> database
      + save(Order order): void
      + findById(UUID id): Order
      + update(Order order): void
    }

    class PaymentGatewayAdapter {
      + processPayment(UUID orderId, Money amount, String paymentMethod): boolean
      + refundPayment(UUID orderId): boolean
      + validateCard(String cardNumber, String cvv, String expiryDate): boolean
      + getPaymentStatus(UUID orderId): String
    }

    OrderRepositoryImpl ..|> OrderRepository
    PaymentGatewayAdapter ..|> PaymentGateway
  }

  package "Order Interface Layer"  {
    class OrderController {
      - OrderService orderService
      + postOrder(User user, List<OrderItem> items): Order
      + payOrder(UUID orderId): void
      + cancelOrder(UUID orderId): void
      + markReady(UUID orderId): void
    }

    OrderController --> OrderService
  }
}

' =============================
' PAYMENT DOMAIN
' =============================
package "Payment Domain" {
  package "Payment Domain Layer"  {
    enum PaymentStatus {
      PENDING,
      COMPLETED,
      FAILED,
      REFUNDED
    }

    class Payment <<Entity>> {
      - UUID id
      - Money amount
      - PaymentStatus status
      + getStatus(): PaymentStatus
      + getAmount(): Money
    }

    class Currency <<ValueObject>> {
      - String code
      + getCode(): String
    }

    interface PaymentProcessor {
      + processPayment(Payment payment): boolean
      + refundPayment(Payment payment): boolean
    }

    Payment --> PaymentStatus
    Payment --> Money
    Money --> Currency
  }

  package "Payment Application Layer"  {
    class PaymentService {
      - PaymentProcessor processor
      + makePayment(Payment payment): boolean
      + issueRefund(Payment payment): boolean
    }

    PaymentService --> Payment
    PaymentService --> PaymentProcessor
  }

  package "Payment Infrastructure Layer"  {
    class StripePaymentAdapter {
      - String stripeApiKey
      + processPayment(Payment payment): boolean
      + refundPayment(Payment payment): boolean
    }

    class "Stripe API" {
      + createPaymentIntent(BigDecimal amount, String currency): String
      + confirmPayment(String paymentIntentId): boolean
    }

    StripePaymentAdapter --> "Stripe API"
    StripePaymentAdapter ..|> PaymentProcessor
  }

  package "Payment Interface Layer"  {
    class PaymentController {
      - PaymentService paymentService
      + pay(Payment payment): boolean
      + refund(Payment payment): boolean
    }

    PaymentController --> PaymentService
  }
}

' =============================
' PRODUCT CATALOG DOMAIN
' =============================
package "Product Catalog Domain" {
  package "Product Catalog Domain Layer"  {
    class ProductId <<ValueObject>> {
      - UUID value
      + getValue(): UUID
    }

    class CategoryId <<ValueObject>> {
      - UUID value
      + getValue(): UUID
    }

    class CategoryName <<ValueObject>> {
      - String value
      + getValue(): String
    }

    class Image <<ValueObject>> {
      - String url
      + getUrl(): String
    }

    class ProductDescription <<ValueObject>> {
      - String value
      + getValue(): String
      + isValid(): boolean
    }

    class Price <<ValueObject>> {
      - float value
      - String currency
      + getValue(): float
      + getCurrency(): String
      + format(): String
      + isValid(): boolean
    }

    class Score <<ValueObject>> {
      - float value
      - int maxValue
      + getValue(): float
      + getPercentage(): float
      + isValid(): boolean
      + compareTo(Score other): int
    }

    class Label <<ValueObject>> {
      - String value
      - String colorCode
      + getValue(): String
      + getColor(): String
      + isValid(): boolean
      + updateColor(String newColor): void
    }

    class Product <<Entity>> {
      - ProductId id
      - String title
      - ProductDescription description
      - Price price
      - List<Label> tags
      - Score rating
      - Image previewImage
      - int stock
      - boolean isActive
      - LocalDateTime createdAt
      - LocalDateTime updatedAt
      + getInfo(): String
      + getPreview(): Image
      + calculateAverageScore(): float
      + addTag(Label tag): void
      + removeTag(Label tag): void
      + updateStock(int newStock): void
      + updateDescription(ProductDescription newDescription): void
      + updatePrice(Price newPrice): void
      + updatePreviewImage(Image newImage): void
      + activate(): void
      + deactivate(): void
    }

    class Category <<Entity>> {
      - CategoryId id
      - CategoryName name
      - String description
      - List<Product> products
      + getName(): String
      + getDescription(): String
      + addProduct(Product product): void
      + removeProduct(Product product): void
    }

    Product *-- ProductId
    Product *-- ProductDescription
    Product *-- Price
    Product *-- Score
    Product *-- "0..*" Label
    Product *-- Image
    Product --> Category : belongs to >
    Category *-- CategoryId
    Category *-- CategoryName
  }

  package "Product Catalog Application Layer"  {
    interface ProductRepository {
      + findAll(): List<Product>
      + findById(ProductId id): Product
      + findByCategory(CategoryId categoryId): List<Product>
      + findByScore(Score minScore): List<Product>
      + findByLabel(Label label): List<Product>
      + findActiveProducts(): List<Product>
      + findOutOfStockProducts(): List<Product>
      + save(Product product): void
      + delete(ProductId id): void
    }

    interface CategoryRepository {
      + findAll(): List<Category>
      + findById(CategoryId id): Category
      + save(Category category): void
      + delete(CategoryId id): void
    }

    class ProductCatalogService {
      - ProductRepository productRepository
      - CategoryRepository categoryRepository
      + listAllProducts(): List<Product>
      + fetchProductById(ProductId id): Product
      + listByCategory(CategoryId categoryId): List<Product>
      + listTopRated(Score minScore): List<Product>
      + listByLabel(Label label): List<Product>
      + listActive(): List<Product>
      + listOutOfStock(): List<Product>
      + updateStock(ProductId id, int newStock): void
      + updateDescription(ProductId id, ProductDescription newDesc): void
      + updatePrice(ProductId id, Price newPrice): void
      + updatePreviewImage(ProductId id, Image newImage): void
      + changeCategory(ProductId id, CategoryId newCategory): void
      + createProduct(Product product): void
      + deleteProduct(ProductId id): void
      + activate(ProductId id): void
      + deactivate(ProductId id): void
    }

    class CategoryService {
      - CategoryRepository categoryRepository
      + listAllCategories(): List<Category>
      + getCategoryById(CategoryId id): Category
      + createCategory(Category category): void
      + updateCategory(CategoryId id, CategoryName name, String description): void
      + deleteCategory(CategoryId id): void
    }

    ProductCatalogService --> ProductRepository
    ProductCatalogService --> CategoryRepository
    CategoryService --> CategoryRepository
  }

  package "Product Catalog Infrastructure Layer"  {
    class ProductRepositoryImpl {
      - List<Product> productsDB
      + findAll(): List<Product>
      + findById(ProductId id): Product
      + findByCategory(CategoryId categoryId): List<Product>
      + findByScore(Score minScore): List<Product>
      + findByLabel(Label label): List<Product>
      + findActiveProducts(): List<Product>
      + findOutOfStockProducts(): List<Product>
      + save(Product product): void
      + delete(ProductId id): void
    }

    class CategoryRepositoryImpl {
      - List<Category> categoriesDB
      + findAll(): List<Category>
      + findById(CategoryId id): Category
      + save(Category category): void
      + delete(CategoryId id): void
    }

    class CloudinaryImageService {
      - String cloudName
      + getImageUrl(String imageId): String
      + deleteImage(String imageUrl): void
      + transformImage(String imageUrl, Map<String, String> options): String
    }

    ProductRepositoryImpl --> CloudinaryImageService
    ProductRepositoryImpl ..|> ProductRepository
    CategoryRepositoryImpl ..|> CategoryRepository
  }

  package "Product Catalog Interface Layer"  {
    class ProductCatalogController {
      - ProductCatalogService catalogService
      + getAll(): List<Product>
      + getById(ProductId id): Product
      + getByCategory(CategoryId categoryId): List<Product>
      + getTopRated(float minScore): List<Product>
      + getByLabel(String label): List<Product>
      + getActive(): List<Product>
      + getOutOfStock(): List<Product>
      + create(Product product): void
      + updateStock(ProductId id, int newStock): void
      + updatePrice(ProductId id, Price newPrice): void
      + updateDescription(ProductId id, ProductDescription newDesc): void
      + updateImage(ProductId id, Image newImage): void
      + changeCategory(ProductId id, CategoryId newCategory): void
      + activate(ProductId id): void
      + deactivate(ProductId id): void
      + delete(ProductId id): void
    }

    class CategoryController {
      - CategoryService categoryService
      + getAllCategories(): List<Category>
      + getCategory(CategoryId id): Category
      + createCategory(Category category): void
      + updateCategory(CategoryId id, CategoryName name, String description): void
      + deleteCategory(CategoryId id): void
    }

    ProductCatalogController --> ProductCatalogService
    CategoryController --> CategoryService
  }
}

' =============================
' USER DOMAIN
' =============================
package "User Domain" {
  package "User Domain Layer"  {
    class User <<Entity>> {
      - UUID id
      - Username username
      - Email email
      - Password password
      - Set<Role> roles
      - Address address
      + boolean isAuthorized(String permission)
      + boolean changePassword(Password oldPassword, Password newPassword)
    }

    class Username <<ValueObject>> {
      - String value
      + Username(String value)
      + String getValue()
      + boolean isValid()
    }

    class Email <<ValueObject>> {
      - String value
      + Email(String value)
      + String getValue()
      + boolean isValid()
    }

    class Password <<ValueObject>> {
      - String hash
      - String salt
      - Date createdAt
      - boolean expired
      + static Password createFromPlainText(String plainText)
      + boolean matches(String plainText)
      + boolean isExpired()
    }

    class Role <<ValueObject>> {
      - String name
      + String getName()
    }

    class Address <<ValueObject>> {
      - String street
      - String city
      - String state
      - String zipCode
      - String country
      + boolean equals(Object other)
      + String toString()
    }

    class Token <<ValueObject>> {
      - String value
      + Token(String value)
      + String getValue()
      + boolean isValid()
    }

    User --> Username
    User --> Email
    User --> Password
    User "1" --> "0..*" Role
    User --> Address

    ' Connect Order to User
    Order "0..*" --> "1" User : customer
  }

  package "User Application Layer"  {
    interface IUserRepository {
      + User findByUsername(Username username)
      + void save(User user)
      + boolean existsByEmail(Email email)
    }

    interface IAuthService {
      + boolean authenticate(Username username, Password password)
      + Token generateToken(User user)
    }

    class UserService {
      - IUserRepository userRepository
      - IAuthService authService
      + boolean registerUser(Username username, Email email, Password password)
      + Token login(Username username, Password password)
      + boolean changePassword(Username username, Password oldPassword, Password newPassword)
    }

    UserService --> IUserRepository
    UserService --> IAuthService
  }

  package "User Infrastructure Layer"  {
    class UserRepositoryImpl {
      + User findByUsername(Username username)
      + void save(User user)
      + boolean existsByEmail(Email email)
    }

    class JwtAuthService {
      + boolean authenticate(Username username, Password password)
      + Token generateToken(User user)
    }

    UserRepositoryImpl ..|> IUserRepository
    JwtAuthService ..|> IAuthService
  }

  package "User Interface Layer"  {
    class UserController {
      - UserService userService
      + ResponseEntity<Boolean> register(String username, String email, String password)
      + ResponseEntity<String> login(String username, String password)
      + ResponseEntity<Boolean> changePassword(String username, String oldPassword, String newPassword)
    }

    UserController --> UserService
  }
}

' Add some high-level context to the diagram
note "E-commerce System with Domain-Driven Design" as N1
@enduml